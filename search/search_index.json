{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>This document will serve as an introduction to and usage example for the libplacebo API. This is not intended as a full API reference, for that you should see the repository of header files, which area written to be (hopefully) understandable as-is.</p> <p>libplacebo exposes large parts of its internal abstractions publicly. This guide will take the general approach of starting as high level as possible and diving into the details in later chapters.</p> <p>A full listing of currently available APIs and their corresponding header files can be seen here.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started using libplacebo, you need to install it (and its development headers) somehow onto your system. On most distributions, this should be as simple as installing the corresponding <code>libplacebo-devel</code> package, or the appropriate variants.</p> <p>You can see a fill list of libplacebo packages and their names on repology.</p> <p>API versions</p> <p>This document is targeting the \"v4 API\" overhaul, and as such, examples provided will generally fail to compile on libplacebo versions below v4.x.</p> <p>Alternatively, you can install it from the source code. For that, see the build instructions located here.</p>"},{"location":"basic-rendering/","title":"Basic windowing / output example","text":"<p>We will demonstrate the basics of the libplacebo GPU output API with a worked example. The goal is to show a simple color on screen.</p>"},{"location":"basic-rendering/#creating-a-pl_log","title":"Creating a <code>pl_log</code>","text":"<p>Almost all major entry-points into libplacebo require providing a log callback (or <code>NULL</code> to disable logging). This is abstracted into the <code>pl_log</code> object type, which we can create with <code>pl_log_create</code>:</p> <pre><code>#include &lt;libplacebo/log.h&gt;\npl_log pllog;\nint main()\n{\npllog = pl_log_create(PL_API_VER, pl_log_params(\n.log_cb = pl_log_color,\n.log_level = PL_LOG_INFO,\n));\n// ...\npl_log_destroy(&amp;pllog);\nreturn 0;\n}\n</code></pre> <p>Compiling</p> <p>You can compile this example with:</p> <pre><code>$ gcc example.c -o example `pkg-config --cflags --libs libplacebo`\n</code></pre> <p>The parameter <code>PL_API_VER</code> has no special significance and is merely included for historical reasons. Aside from that, this snippet introduces a number of core concepts of the libplacebo API:</p>"},{"location":"basic-rendering/#parameter-structs","title":"Parameter structs","text":"<p>For extensibility, almost all libplacebo calls take a pointer to a <code>const struct pl_*_params</code>, into which all extensible parameters go. For convenience, libplacebo provides macros which create anonymous params structs on the stack (and also fill in default parameters). Note that this only works for C99 and above, users of C89 and C++ must initialize parameter structs manually.</p> <p>Under the hood, <code>pl_log_params(...)</code> just translates to <code>&amp;((struct pl_log_params) { /* default params */, ... })</code>. This style of API allows libplacebo to effectively simulate optional named parameters.</p> <p>On default parameters</p> <p>Wherever possible, parameters are designed in such a way that <code>{0}</code> gives you a minimal parameter structure, with default behavior and no optional features enabled. This is done for forwards compatibility - as new features are introduced, old struct initializers will simply opt out of them.</p>"},{"location":"basic-rendering/#destructors","title":"Destructors","text":"<p>All libplacebo objects must be destroyed manually using the corresponding <code>pl_*_destroy</code> call, which takes a pointer to the variable the object is stored in. The resulting variable is written to <code>NULL</code>. This helps prevent use-after-free bugs.</p> <p>NULL</p> <p>As a general rule, all libplacebo destructors are safe to call on variables containing <code>NULL</code>. So, users need not explicitly <code>NULL</code>-test before calling destructors on variables.</p>"},{"location":"basic-rendering/#creating-a-window","title":"Creating a window","text":"<p>While libplacebo can work in isolation, to render images offline, for the sake of this guide we want to provide something graphical on-screen. As such, we need to create some sort of window. Libplacebo provides no built-in mechanism for this, it assumes the API user will already have a windowing system in-place.</p> <p>Complete examples (based on GLFW and SDL) can be found in the libplacebo demos. But for now, we will focus on getting a very simple window on-screen using GLFW:</p> <pre><code>// ...\n#include &lt;GLFW/glfw3.h&gt;\nconst char * const title = \"libplacebo demo\";\nint width = 800;\nint height = 600;\nGLFWwindow *window;\nint main()\n{\npllog = pl_log_create(PL_API_VER, pl_log_params(\n.log_level = PL_LOG_INFO,\n));\nif (!glfwInit())\nreturn 1;\nwindow = glfwCreateWindow(width, height, title, NULL, NULL);\nif (!window)\nreturn 1;\nwhile (!glfwWindowShouldClose(window)) {\nglfwWaitEvents();\n}\nglfwDestroyWindow(window);\nglfwTerminate();\npl_log_destroy(&amp;pllog);\nreturn 0;\n}\n</code></pre> <p>Compiling</p> <p>We now also need to include the glfw3 library to compile this example.</p> <pre><code>$ gcc example.c -o example `pkg-config --cflags --libs glfw3 libplacebo`\n</code></pre>"},{"location":"basic-rendering/#creating-the-pl_gpu","title":"Creating the <code>pl_gpu</code>","text":"<p>All GPU operations are abstracted into an internal <code>pl_gpu</code> object, which serves as the primary entry-point to any sort of GPU interaction. This object cannot be created directly, but must be obtained from some graphical API: currently there are Vulkan, OpenGL or D3D11. A <code>pl_gpu</code> can be accessed from an API-specific object like <code>pl_vulkan</code>, <code>pl_opengl</code> and <code>pl_d3d11</code>.</p> <p>In this guide, for simplicity, we will be using OpenGL, simply because that's what GLFW initializes by default.</p> <pre><code>// ...\npl_opengl opengl;\nstatic bool make_current(void *priv);\nstatic void release_current(void *priv);\nint main()\n{\n// ...\nwindow = glfwCreateWindow(width, height, title, NULL, NULL);\nif (!window)\nreturn 1;\nopengl = pl_opengl_create(pllog, pl_opengl_params(\n.get_proc_addr      = glfwGetProcAddress,\n.allow_software     = true,         // allow software rasterers\n.debug              = true,         // enable error reporting\n.make_current       = make_current, // (1)\n.release_current    = release_current,\n));\nif (!opengl)\nreturn 2;\nwhile (!glfwWindowShouldClose(window)) {\nglfwWaitEvents();\n}\npl_opengl_destroy(&amp;opengl);\nglfwDestroyWindow(window);\nglfwTerminate();\npl_log_destroy(&amp;pllog);\nreturn 0;\n}\nstatic bool make_current(void *priv)\n{\nglfwMakeContextCurrent(window);\nreturn true;\n}\nstatic void release_current(void *priv)\n{\nglfwMakeContextCurrent(NULL);\n}\n</code></pre> <ol> <li> <p>Setting this allows the resulting <code>pl_gpu</code> to be thread-safe, which     enables asynchronous transfers to be used. The alternative is to simply     call <code>glfwMakeContextCurrent</code> once after creating the window.</p> <p>This method of making the context current is generally preferred, however, so we've demonstrated it here for completeness' sake.</p> </li> </ol>"},{"location":"basic-rendering/#creating-a-swapchain","title":"Creating a swapchain","text":"<p>All access to window-based rendering commands are abstracted into an object known as a \"swapchain\" (from Vulkan terminology), including the default backbuffers on D3D11 and OpenGL. If we want to present something to screen, we need to first create a <code>pl_swapchain</code>.</p> <p>We can use this swapchain to perform the equivalent of <code>gl*SwapBuffers</code>:</p> <pre><code>// ...\npl_swapchain swchain;\nstatic void resize_cb(GLFWwindow *win, int new_w, int new_h)\n{\nwidth  = new_w;\nheight = new_h;\npl_swapchain_resize(swchain, &amp;width, &amp;height);\n}\nint main()\n{\n// ...\nif (!opengl)\nreturn 2;\nswchain = pl_opengl_create_swapchain(opengl, pl_opengl_swapchain_params(\n.swap_buffers   = (void (*)(void *)) glfwSwapBuffers,\n.priv           = window,\n));\nif (!swchain)\nreturn 2;\n// (2)\nif (!pl_swapchain_resize(swchain, &amp;width, &amp;height))\nreturn 2;\nglfwSetFramebufferSizeCallback(window, resize_cb);\nwhile (!glfwWindowShouldClose(window)) {\npl_swapchain_swap_buffers(swchain);\nglfwPollEvents(); // (1)\n}\npl_swapchain_destroy(&amp;swchain);\npl_opengl_destroy(&amp;opengl);\nglfwDestroyWindow(window);\nglfwTerminate();\npl_log_destroy(&amp;pllog);\nreturn 0;\n}\n</code></pre> <ol> <li> <p>We change this from <code>glfwWaitEvents</code> to <code>glfwPollEvents</code> because     we now want to re-run our main loop once per vsync, rather than only when     new events arrive.  The <code>pl_swapchain_swap_buffers</code> call will ensure     that this does not execute too quickly.</p> </li> <li> <p>The swapchain needs to be resized to fit the size of the window, which in     GLFW is handled by listening to a callback. In addition to setting this     callback, we also need to inform the swapchain of the initial window size.</p> <p>Note that the <code>pl_swapchain_resize</code> function handles both resize requests and size queries - hence, the actual swapchain size is returned back to the passed variables.</p> </li> </ol>"},{"location":"basic-rendering/#getting-pixels-on-the-screen","title":"Getting pixels on the screen","text":"<p>With a swapchain in hand, we're now equipped to start drawing pixels to the screen:</p> <pre><code>// ...\nstatic void render_frame(struct pl_swapchain_frame frame)\n{\npl_gpu gpu = opengl-&gt;gpu;\npl_tex_clear(gpu, frame.fbo, (float[4]){ 1.0, 0.5, 0.0, 1.0 });\n}\nint main()\n{\n// ...\nwhile (!glfwWindowShouldClose(window)) {\nstruct pl_swapchain_frame frame;\nwhile (!pl_swapchain_start_frame(swchain, &amp;frame))\nglfwWaitEvents(); // (1)\nrender_frame(frame);\nif (!pl_swapchain_submit_frame(swchain))\nbreak; // (2)\npl_swapchain_swap_buffers(swchain);\nglfwPollEvents();\n}\n// ...\n}\n</code></pre> <ol> <li> <p>If <code>pl_swapchain_start_frame</code> fails, it typically means the window is     hidden, minimized or blocked. This is not a fatal condition, and as such     we simply want to process window events until we can resume rendering.</p> </li> <li> <p>If <code>pl_swapchain_submit_frame</code> fails, it typically means the window has     been lost, and further rendering commands are not expected to succeed.     As such, in this case, we simply terminate the example program.</p> </li> </ol> <p>Our main render loop has changed into a combination of <code>pl_swapchain_start_frame</code>, rendering, and <code>pl_swapchain_submit_frame</code>. To start with, we simply use the <code>pl_tex_clear</code> function to blit a constant orange color to the framebuffer.</p>"},{"location":"basic-rendering/#interlude-rendering-commands","title":"Interlude: Rendering commands","text":"<p>The previous code snippet represented our first foray into the <code>pl_gpu</code> API. For more detail on this API, see the GPU API section. But as a general rule of thumb, all <code>pl_gpu</code>-level operations are thread safe, asynchronous (except when returning something to the CPU), and internally refcounted (so you can destroy all objects as soon as you no longer need the reference).</p> <p>In the example loop, <code>pl_swapchain_swap_buffers</code> is the only operation that actually flushes commands to the GPU. You can force an early flush with <code>pl_gpu_flush()</code> or <code>pl_gpu_finish()</code>, but other than that, commands will \"queue\" internally and complete asynchronously at some unknown point in time, until forward progress is needed (e.g. <code>pl_tex_download</code>).</p>"},{"location":"basic-rendering/#conclusion","title":"Conclusion","text":"<p>We have demonstrated how to create a window, how to initialize the libplacebo API, create a GPU instance based on OpenGL, and how to write a basic rendering loop that blits a single color to the framebuffer.</p> <p>Here is a complete transcript of the example we built in this section:</p> Basic rendering <pre><code>#include &lt;GLFW/glfw3.h&gt;\n#include &lt;libplacebo/log.h&gt;\n#include &lt;libplacebo/opengl.h&gt;\n#include &lt;libplacebo/gpu.h&gt;\nconst char * const title = \"libplacebo demo\";\nint width = 800;\nint height = 600;\nGLFWwindow *window;\npl_log pllog;\npl_opengl opengl;\npl_swapchain swchain;\nstatic bool make_current(void *priv);\nstatic void release_current(void *priv);\nstatic void resize_cb(GLFWwindow *win, int new_w, int new_h)\n{\nwidth  = new_w;\nheight = new_h;\npl_swapchain_resize(swchain, &amp;width, &amp;height);\n}\nstatic void render_frame(struct pl_swapchain_frame frame)\n{\npl_gpu gpu = opengl-&gt;gpu;\npl_tex_clear(gpu, frame.fbo, (float[4]){ 1.0, 0.5, 0.0, 1.0 });\n}\nint main()\n{\npllog = pl_log_create(PL_API_VER, pl_log_params(\n.log_cb = pl_log_color,\n.log_level = PL_LOG_INFO,\n));\nif (!glfwInit())\nreturn 1;\nwindow = glfwCreateWindow(width, height, title, NULL, NULL);\nif (!window)\nreturn 1;\nopengl = pl_opengl_create(pllog, pl_opengl_params(\n.get_proc_addr      = glfwGetProcAddress,\n.allow_software     = true,         // allow software rasterers\n.debug              = true,         // enable error reporting\n.make_current       = make_current,\n.release_current    = release_current,\n));\nswchain = pl_opengl_create_swapchain(opengl, pl_opengl_swapchain_params(\n.swap_buffers   = (void (*)(void *)) glfwSwapBuffers,\n.priv           = window,\n));\nif (!swchain)\nreturn 2;\nif (!pl_swapchain_resize(swchain, &amp;width, &amp;height))\nreturn 2;\nglfwSetFramebufferSizeCallback(window, resize_cb);\nwhile (!glfwWindowShouldClose(window)) {\nstruct pl_swapchain_frame frame;\nwhile (!pl_swapchain_start_frame(swchain, &amp;frame))\nglfwWaitEvents();\nrender_frame(frame);\nif (!pl_swapchain_submit_frame(swchain))\nbreak;\npl_swapchain_swap_buffers(swchain);\nglfwPollEvents();\n}\npl_swapchain_destroy(&amp;swchain);\npl_opengl_destroy(&amp;opengl);\nglfwDestroyWindow(window);\nglfwTerminate();\npl_log_destroy(&amp;pllog);\nreturn 0;\n}\nstatic bool make_current(void *priv)\n{\nglfwMakeContextCurrent(window);\nreturn true;\n}\nstatic void release_current(void *priv)\n{\nglfwMakeContextCurrent(NULL);\n}\n</code></pre>"},{"location":"custom-shaders/","title":"Custom Shaders (mpv .hook syntax)","text":"<p>libplacebo supports the same custom shader syntax used by mpv, with some important changes. This document will serve as a complete reference for this syntax.</p>"},{"location":"custom-shaders/#overview","title":"Overview","text":"<p>In general, user shaders are divided into distinct blocks. Each block can define a shader, a texture, a buffer, or a tunable parameter. Each block starts with a collection of header directives, which are lines starting with the syntax <code>//!</code>.</p> <p>As an example, here is a simple shader that simply inverts the video signal:</p> <pre><code>//!HOOK LUMA\n//!HOOK RGB\n//!BIND HOOKED\nvec4 hook()\n{\nvec4 color = HOOKED_texOff(0);\ncolor.rgb = vec3(1.0) - color.rgb;\nreturn color;\n}\n</code></pre> <p>This shader defines one block - a shader block which hooks into the two texture stages <code>LUMA</code> and <code>RGB</code>, binds the hooked texture, inverts the value of the <code>rgb</code> channels, and then returns the modified color.</p>"},{"location":"custom-shaders/#expressions","title":"Expressions","text":"<p>In a few contexts, shader directives accept arithmetic expressions, denoted by <code>&lt;expr&gt;</code> in the listing below. For historical reasons, all expressions are given in reverse polish notation (RPN), and the only value type is a floating point number. The following value types and arithmetic operations are available:</p> <ul> <li><code>1.234</code>: Literal float constant, evaluates to itself.</li> <li><code>NAME.w</code>, <code>NAME.width</code>: Evaluates to the width of a texture with name <code>NAME</code>.</li> <li><code>NAME.h</code>, <code>NAME.height</code>: Evaluates to the height of a texture with name <code>NAME</code>.</li> <li><code>PAR</code>: Evaluates to the value of a tunable shader parameter with name <code>PAR</code>.</li> <li><code>+</code>: Evaluates to <code>X+Y</code>.</li> <li><code>-</code>: Evaluates to <code>X-Y</code>.</li> <li><code>*</code>: Evaluates to <code>X*Y</code>.</li> <li><code>/</code>: Evaluates to <code>X/Y</code>.</li> <li><code>%</code>: Evaluates to <code>fmod(X, Y)</code>.</li> <li><code>&gt;</code>: Evaluates to <code>(X &gt; Y) ? 1.0 : 0.0</code>.</li> <li><code>&lt;</code>: Evaluates to <code>(X &lt; Y) ? 1.0 : 0.0</code>.</li> <li><code>=</code>: Evaluates to <code>fuzzy_eq(X, Y) ? 1.0 : 0.0</code>, with some tolerance to   allow for floating point inaccuracy. (Around 1 ppm)</li> <li><code>!</code>: Evaluates to <code>X ? 0.0 : 1.0</code>.</li> </ul> <p>Note that <code>+</code> and <code>*</code> can be used as suitable replacements for the otherwise absent boolean logic expressions (<code>||</code> and <code>&amp;&amp;</code>).</p>"},{"location":"custom-shaders/#shaders","title":"Shaders","text":"<p>Shaders are the default block type, and have no special syntax to indicate their presence. Shader stages contain raw GLSL code that will be (conditionally) executed. This GLSL snippet must define a single function <code>vec4 hook()</code>, or <code>void hook()</code> for compute shaders.</p> <p>During the execution of any shader, the following global variables are made available:</p> <ul> <li><code>int frame</code>: A raw counter tracking the number of executions of this shader   stage.</li> <li><code>float random</code>: A pseudo-random float uniformly distributed in the range   <code>[0,1)</code>.</li> <li><code>vec2 input_size</code>: The nominal size (in pixels) of the original input image.</li> <li><code>vec2 target_size</code>: The nominal size (in pixels) of the output rectangle.</li> <li><code>vec2 tex_offset</code>: The nominal offset (in pixels), of the original input crop.</li> <li><code>vec4 linearize(vec4 color)</code>: Linearize the input color according to the   image's tagged gamma function.</li> <li><code>vec4 delinearize(vec4 color)</code>: Opposite counterpart to <code>linearize</code>.</li> </ul> <p>Shader stages accept the following directives:</p>"},{"location":"custom-shaders/#hook-texture","title":"<code>HOOK &lt;texture&gt;</code>","text":"<p>A <code>HOOK</code> directive determines when a shader stage is run. During internal processing, libplacebo goes over a number of pre-defined hook points at set points in the processing pipeline. It is only possible to intercept the image, and run custom shaders, at these fixed hook points.</p> <p>Here is a current list of hook points:</p> <ul> <li><code>RGB</code>: Input plane containing RGB values</li> <li><code>LUMA</code>: Input plane containing a Y value</li> <li><code>CHROMA</code>: Input plane containing chroma values (one or both)</li> <li><code>ALPHA</code>: Input plane containing a single alpha value</li> <li><code>XYZ</code>: Input plane containing XYZ values</li> <li><code>CHROMA_SCALED</code>: Chroma plane, after merging and upscaling to luma size</li> <li><code>ALPHA_SCALED</code>: Alpha plane, after upscaling to luma size</li> <li><code>NATIVE</code>: Merged input planes, before any sort of color conversion (as-is)</li> <li><code>MAIN</code>: After conversion to RGB, before linearization/scaling</li> <li><code>LINEAR</code>: After conversion to linear light (for scaling purposes)</li> <li><code>SIGMOID</code>: After conversion to sigmoidized light (for scaling purposes)</li> <li><code>PREKERNEL</code>: Immediately before the execution of the main scaler kernel</li> <li><code>POSTKERNEL</code>: Immediately after the execution of the main scaler kernel</li> <li><code>SCALED</code>: After scaling, in either linear or non-linear light RGB</li> <li><code>OUTPUT</code>: After color conversion to the output display's native colorspace</li> </ul> <p><code>MAINPRESUB</code></p> <p>In mpv, <code>MAIN</code> and <code>MAINPRESUB</code> are separate shader stages, because the mpv option <code>--blend-subtitles=video</code> allows rendering overlays directly onto the pre-scaled video stage. libplacebo does not support this feature, and as such, the <code>MAINPRESUB</code> shader stage does not exist. It is still valid to refer to this name in shaders, but it is handled identically to <code>MAIN</code>.</p> <p>It's possible for a hook point to never fire. For example, <code>SIGMOID</code> will not fire when downscaling, as sigmoidization only happens when upscaling. Similarly, <code>LUMA</code>/<code>CHROMA</code> will not fire on an RGB video and vice versa.</p> <p>A single shader stage may hook multiple hook points simultaneously, for example, to cover both <code>LUMA</code> and <code>RGB</code> cases with the same logic. (See the example shader in the introduction)</p>"},{"location":"custom-shaders/#bind-texture","title":"<code>BIND &lt;texture&gt;</code>","text":"<p>The <code>BIND</code> directive makes a texture available for use in the shader. This can be any of the previously named hook points, a custom texture define by a <code>TEXTURE</code> block, a custom texture saved by a <code>SAVE</code> directive, or the special value <code>HOOKED</code> which allows binding whatever texture hook dispatched this shader stage.</p> <p>A bound texture will define the following GLSL functions (as macros):</p> <ul> <li><code>sampler2D NAME_raw</code>: A reference to the raw texture sampler itself.</li> <li><code>vec2 NAME_pos</code>: The texel coordinates of the current pixel.</li> <li><code>vec2 NAME_map(ivec2 id)</code>: A function that maps from <code>gl_GlobalInvocationID</code>   to texel coordinates. (Compute shaders)</li> <li><code>vec2 NAME_size</code>: The size (in pixels) of the texture.</li> <li><code>vec2 NAME_pt</code>: Convenience macro for <code>1.0 / NAME_size</code>. The size of a   single pixel (in texel coordinates).</li> <li><code>vec2 NAME_off</code>: The sample offset of the texture. Basically, the pixel   coordinates of the top-left corner of the sampled area.</li> <li><code>float NAME_mul</code>: The coefficient that must be multiplied into sampled   values in order to rescale them to <code>[0,1]</code>.</li> <li><code>vec4 NAME_tex(vec2 pos)</code>: A wrapper around <code>NAME_mul * texture(NAME_raw,   pos)</code>, which picks the correct <code>texture</code> function for the version of GLSL in   use.</li> <li><code>vec4 NAME_texOff(vec2 offset)</code>: A wrapper around <code>NAME_tex(NAME_pos + NAME_pt * offset)</code>.   This can be used to easily access adjacent pixels, e.g. <code>NAME_texOff(-1,2)</code>   samples a pixel one to the left and two to the bottom of the current   location.</li> <li><code>vec4 NAME_gather(vec2 pos, int c)</code>: A wrapper around   <code>NAME_mul * textureGather(pos, c)</code>, with appropriate scaling. (Only when   supported1)</li> </ul> <p>Rotation matrix</p> <p>For compatibility with mpv, we also define a <code>mat2 NAME_rot</code> which is simply equal to a 2x2 identity matrix. libplacebo never rotates input planes - all rotation happens during the final output to the display.</p> <p>This same directive can also be used to bind buffer blocks (i.e. uniform/storage buffers), as defined by the <code>BUFFER</code> directive.</p>"},{"location":"custom-shaders/#save-texture","title":"<code>SAVE &lt;texture&gt;</code>","text":"<p>By default, after execution of a shader stage, the resulting output is captured back into the same hooked texture that triggered the shader. This behavior can be overridden using the explicit <code>SAVE</code> directive. For example, a shader might need access to a low-res version of the luma input texture in order to process chroma:</p> <pre><code>//!HOOK CHROMA\n//!BIND CHROMA\n//!BIND LUMA\n//!SAVE LUMA_LOWRES\n//!WIDTH CHROMA.w\n//!HEIGHT CHROMA.h\nvec4 hook()\n{\nreturn LUMA_texOff(0);\n}\n</code></pre> <p>This shader binds both luma and chroma and resizes the luma plane down to the size of the chroma plane, saving the result as a new texture <code>LUMA_LOWRES</code>. In general, you can pick any name you want, here.</p>"},{"location":"custom-shaders/#desc-description","title":"<code>DESC &lt;description&gt;</code>","text":"<p>This purely informative directive simply gives the shader stage a name. This is the name that will be reported to the shader stage and execution time metrics.</p>"},{"location":"custom-shaders/#offset-xo-yo-align","title":"<code>OFFSET &lt;xo yo | ALIGN&gt;</code>","text":"<p>This directive indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected automatically as part of plane alignment / main scaling.</p> <p>A special value of <code>ALIGN</code> will attempt to counteract any existing offset of the hooked texture by aligning it with reference plane (i.e. luma). This can be used to e.g. introduce custom chroma scaling in a way that doesn't break chroma subtexel offsets.</p> <p>An example:</p> <pre><code>//!HOOK LUMA\n//!BIND HOOKED\n//!OFFSET 100.5 100.5\nvec4 hook()\n{\n// Constant offset by N pixels towards the bottom right\nreturn HOOKED_texOff(-vec2(100.5));\n}\n</code></pre> <p>This (slightly silly) shader simply shifts the entire sampled region to the bottom right by 100.5 pixels, and propagates this shift to the main scaler using the <code>OFFSET</code> directive. As such, the end result of this is that there is no visible shift of the overall image, but some detail (~100 pixels) near the bottom-right border is lost due to falling outside the bounds of the texture.</p>"},{"location":"custom-shaders/#width-expr-height-expr","title":"<code>WIDTH &lt;expr&gt;</code>, <code>HEIGHT &lt;expr&gt;</code>","text":"<p>These directives can be used to override the dimensions of the resulting texture. Note that not all textures can be resized this way. Currently, only <code>RGB</code>, <code>LUMA</code>, <code>CHROMA</code>, <code>XYZ</code>, <code>NATIVE</code> and <code>MAIN</code> are resizable. Trying to save a texture with an incompatible size to any other shader stage will result in an error.</p>"},{"location":"custom-shaders/#when-expr","title":"<code>WHEN &lt;expr&gt;</code>","text":"<p>This directive takes an expression that can be used to make shader stages conditionally executed. If this evaluates to 0, the shader stage will be skipped.</p> <p>Example:</p> <pre><code>//!PARAM strength\n//!TYPE float\n//!MINIMUM 0\n1.0\n//!HOOK MAIN\n//!BIND HOOKED\n//!WHEN intensity 0 &gt;\n//!DESC do something based on 'intensity'\n...\n</code></pre> <p>This example defines a shader stage that only conditionally executes itself if the value of the <code>intensity</code> shader parameter is non-zero.</p>"},{"location":"custom-shaders/#components-num","title":"<code>COMPONENTS &lt;num&gt;</code>","text":"<p>This directive overrides the number of components present in a texture. For example, if you want to extract a one-dimensional feature map from the otherwise 3 or 4 dimensional <code>MAIN</code> texture, you can use this directive to save on memory bandwidth and consumption by having libplacebo only allocate a one-component texture to store the feature map in:</p> <pre><code>//!HOOK MAIN\n//!BIND HOOKED\n//!SAVE featuremap\n//!COMPONENTS 1\n</code></pre>"},{"location":"custom-shaders/#compute-bw-bh-tw-th","title":"<code>COMPUTE &lt;bw&gt; &lt;bh&gt; [&lt;tw&gt; &lt;th&gt;]</code>","text":"<p>This directive specifies that the shader should be treated as a compute shader, with the block size <code>bw</code> and <code>bh</code>. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be <code>tw*th</code> threads, forming a single work group. In other words: <code>tw</code> and <code>th</code> specify the work group size, which can be different from the block size. So for example, a compute shader with <code>bw = bh = 32</code> and <code>tw = th = 8</code> running on a <code>500x500</code> texture would dispatch <code>16x16</code> blocks (rounded up), each with <code>8x8</code> threads.</p> <p>Instead of defining a <code>vec4 hook()</code>, compute shaders must define a <code>void hook()</code> which results directly to the output texture, a <code>writeonly image2D out_image</code> made available to the shader stage.</p> <p>For example, here is a shader executing a single-pass 41x41 convolution (average blur) on the luma plane, using a compute shader to share sampling work between adjacent threads in a work group:</p> <pre><code>//!HOOK LUMA\n//!BIND HOOKED\n//!COMPUTE 32 32\n//!DESC avg convolution\n// Kernel size, 41x41 as an example\nconst ivec2 ksize = ivec2(41, 41);\nconst ivec2 offset = ksize / 2;\n// We need to load extra source texels to account for padding due to kernel\n// overhang\nconst ivec2 isize = ivec2(gl_WorkGroupSize) + ksize - 1;\nshared float inp[isize.y][isize.x];\nvoid hook()\n{\n// load texels into shmem\nivec2 base = ivec2(gl_WorkGroupID) * ivec2(gl_WorkGroupSize);\nfor (uint y = gl_LocalInvocationID.y; y &lt; isize.y; y += gl_WorkGroupSize.y) {\nfor (uint x = gl_LocalInvocationID.x; x &lt; isize.x; x += gl_WorkGroupSize.x)\ninp[y][x] = texelFetch(HOOKED_raw, base + ivec2(x,y) - offset, 0).x;\n}\n// synchronize threads\nbarrier();\n// do convolution\nfloat sum;\nfor (uint y = 0; y &lt; ksize.y; y++) {\nfor (uint x = 0; x &lt; ksize.x; x++)\nsum += inp[gl_LocalInvocationID.y+y][gl_LocalInvocationID.x+x];\n}\nvec4 color = vec4(HOOKED_mul * sum / (ksize.x * ksize.y), 0, 0, 1);\nimageStore(out_image, ivec2(gl_GlobalInvocationID), color);\n}\n</code></pre>"},{"location":"custom-shaders/#textures","title":"Textures","text":"<p>Custom textures can be defined and made available to shader stages using <code>TEXTURE</code> blocks. These can be used to provide e.g. LUTs or pre-trained weights.</p> <p>The data for a texture is provided as a raw hexadecimal string encoding the in-memory representation of a texture, according to its given texture format, for example:</p> <pre><code>//!TEXTURE COLORS\n//!SIZE 3 3\n//!FORMAT rgba32f\n//!FILTER NEAREST\n//!BORDER REPEAT\n0000803f000000000000000000000000000000000000803f00000000000000000000000\n0000000000000803f00000000000000000000803f0000803f000000000000803f000000\n000000803f000000000000803f0000803f00000000000000009a99993e9a99993e9a999\n93e000000009a99193F9A99193f9a99193f000000000000803f0000803f0000803f0000\n0000\n</code></pre> <p>Texture blocks accept the following directives:</p>"},{"location":"custom-shaders/#texture-name","title":"<code>TEXTURE &lt;name&gt;</code>","text":"<p>This must be the first directive in a texture block, and marks it as such. The name given is the name that the texture will be referred to (via <code>BIND</code> directives).</p>"},{"location":"custom-shaders/#size-width-height-depth","title":"<code>SIZE &lt;width&gt; [&lt;height&gt; [&lt;depth&gt;]]</code>","text":"<p>This directive gives the size of the texture, as integers. For example, <code>//!SIZE 512 512</code> marks a 512x512 texture block. Textures can be 1D, 2D or 3D depending on the number of coordinates specified.</p>"},{"location":"custom-shaders/#format-fmt","title":"<code>FORMAT &lt;fmt&gt;</code>","text":"<p>This directive specifies the texture format. A complete list of known textures is exposed as part of the <code>pl_gpu</code> struct metadata, but they follow the format convention <code>rgba8</code>, <code>rg16hf</code>, <code>rgba32f</code>, <code>r64i</code> and so on.</p>"},{"location":"custom-shaders/#filter-linear-nearest","title":"<code>FILTER &lt;LINEAR | NEAREST&gt;</code>","text":"<p>This directive specifies the texture magnification/minification filter.</p>"},{"location":"custom-shaders/#border-clamp-repeat-mirror","title":"<code>BORDER &lt;CLAMP | REPEAT | MIRROR&gt;</code>","text":"<p>This directive specifies the border clamping method of the texture.</p>"},{"location":"custom-shaders/#storage","title":"<code>STORAGE</code>","text":"<p>If present, this directive marks the texture as a storage image. It will still be initialized with the initial values, but rather than being bound as a read-only and immutable <code>sampler2D</code>, it is bound as a <code>readwrite coherent image2D</code>. Such texture scan be used to, for example, store persistent state across invocations of the shader.</p>"},{"location":"custom-shaders/#buffers","title":"Buffers","text":"<p>Custom uniform / storage shader buffer  blocks can be defined using <code>BUFFER</code> directives.</p> <p>The (initial) data for a buffer is provided as a raw hexadecimal string encoding the in-memory representation of a buffer in the corresponding GLSL packing layout (std140 or std430 for uniform and storage blocks, respectively):</p> <pre><code>//!BUFFER buf_uniform\n//!VAR float foo\n//!VAR float bar\n0000000000000000\n//!BUFFER buf_storage\n//!VAR vec2 bat\n//!VAR int big[32];\n//!STORAGE\n</code></pre> <p>Buffer blocks accept the following directives:</p>"},{"location":"custom-shaders/#buffer-name","title":"<code>BUFFER &lt;name&gt;</code>","text":"<p>This must be the first directive in a buffer block, and marks it as such. The name given is mostly cosmetic, as individual variables can be accessed directly using the names given in the corresponding <code>VAR</code> directives.</p>"},{"location":"custom-shaders/#storage_1","title":"<code>STORAGE</code>","text":"<p>If present, this directive marks the buffer as a (readwrite coherent) shader storage block, instead of a readonly uniform buffer block. Such storage blocks can be used to track and evolve state across invocations of this shader.</p> <p>Storage blocks may also be initialized with default data, but this is optional. They can also be initialized as part of the first shader execution (e.g. by testing for <code>frame == 0</code>).</p>"},{"location":"custom-shaders/#var-type-name","title":"<code>VAR &lt;type&gt; &lt;name&gt;</code>","text":"<p>This directive appends a new variable to the shader block, with GLSL type <code>&lt;type&gt;</code> and shader name <code>&lt;name&gt;</code>. For example, <code>VAR float foo</code> introduces a <code>float foo;</code> member into the buffer block, and <code>VAR mat4 transform</code> introduces a <code>mat4 transform;</code> member.</p> <p>It is also possible to introduce array variables, using <code>[N]</code> as part of the variable name.</p>"},{"location":"custom-shaders/#tunable-parameters","title":"Tunable parameters","text":"<p>Finally, the <code>PARAM</code> directive allows introducing tunable shader parameters, which are exposed programmatically as part of the C API (<code>pl_hook</code>).2</p> <p>The default value of a parameter is given as the block body, for example:</p> <pre><code>//!PARAM contrast\n//!DESC Gain to apply to image brightness\n//!TYPE float\n//!MINIMUM 0.0\n//!MAXIMUM 100.0\n1.0\n</code></pre> <p>Parameters accept the following directives:</p>"},{"location":"custom-shaders/#param-name","title":"<code>PARAM &lt;name&gt;</code>","text":"<p>This must be the first directive in a parameter block, and marks it as such. The name given is the name that will be used to refer to this parameter in GLSL code.</p>"},{"location":"custom-shaders/#desc-description_1","title":"<code>DESC &lt;description&gt;</code>","text":"<p>This directive can be used to provide a friendlier description of the shader parameter, exposed as part of the C API to end users.</p>"},{"location":"custom-shaders/#minimum-value-maximum-value","title":"<code>MINIMUM &lt;value&gt;</code>, <code>MAXIMUM &lt;value&gt;</code>","text":"<p>Provides the minimum/maximum value bound of this parameter. If absent, no minimum/maximum is enforced.</p>"},{"location":"custom-shaders/#type-define-dynamic-constant-type","title":"<code>TYPE &lt;DEFINE | [DYNAMIC | CONSTANT] &lt;type&gt;&gt;</code>","text":"<p>This gives the type of the parameter, which determines what type of values it can hold and how it will be made available to the shader. <code>&lt;type&gt;</code> must be a scalar GLSL numeric type, such as <code>int</code>, <code>float</code> or <code>uint</code>.</p> <p>The optional qualifiers <code>DYNAMIC</code> or <code>CONSTANT</code> mark the parameter as dynamically changing and compile-time constant, respectively. A <code>DYNAMIC</code> variable is assumed to change frequently, and will be grouped with other frequently-changing input parameters. A <code>CONSTANT</code> parameter will be introduced as a compile-time constant into the shader header, which means thy can be used in e.g. constant expressions such as array sizes.3</p> <p>Finally, the special type <code>TYPE DEFINE</code> marks a variable as a preprocessor define, which can be used inside <code>#if</code> preprocessor expressions. For example:</p> <pre><code>//!PARAM taps\n//!DESC Smoothing taps\n//!TYPE DEFINE\n//!MINIMUM 0\n//!MAXIMUM 5\n2\n//!HOOK LUMA\n//!BIND HOOKED\nconst uint row_size = 2 * taps + 1;\nconst float weights[row_size] = {\n#if taps == 0\n1.0,\n#endif\n#if taps == 1\n0.10650697891920,\n0.78698604216159,\n0.10650697891920,\n#endif\n#if taps == 2\n0.05448868454964,\n0.24420134200323,\n0.40261994689424,\n0.24420134200323,\n0.05448868454964,\n#endif\n// ...\n};\n</code></pre>"},{"location":"custom-shaders/#full-example","title":"Full example","text":"<p>A collection of full examples can be found in the mpv user shaders wiki, but here is an example of a parametrized Gaussian smoothed film grain compute shader:</p> <pre><code>//!PARAM intensity\n//!DESC Film grain intensity\n//!TYPE float\n//!MINIMUM 0\n0.1\n//!PARAM taps\n//!DESC Film grain smoothing taps\n//!TYPE DEFINE\n//!MINIMUM 0\n//!MAXIMUM 5\n2\n//!HOOK LUMA\n//!BIND HOOKED\n//!DESC Apply gaussian smoothed film grain\n//!WHEN intensity 0 &gt;\n//!COMPUTE 32 32\nconst uint row_size = 2 * taps + 1;\nconst float weights[row_size] = {\n#if taps == 0\n1.0,\n#endif\n#if taps == 1\n0.10650697891920,\n0.78698604216159,\n0.10650697891920,\n#endif\n#if taps == 2\n0.05448868454964,\n0.24420134200323,\n0.40261994689424,\n0.24420134200323,\n0.05448868454964,\n#endif\n#if taps == 3\n0.03663284536919,\n0.11128075847888,\n0.21674532140370,\n0.27068214949642,\n0.21674532140370,\n0.11128075847888,\n0.03663284536919,\n#endif\n#if taps == 4\n0.02763055063889,\n0.06628224528636,\n0.12383153680577,\n0.18017382291138,\n0.20416368871516,\n0.18017382291138,\n0.12383153680577,\n0.06628224528636,\n0.02763055063889,\n#endif\n#if taps == 5\n0.02219054849244,\n0.04558899978527,\n0.07981140824009,\n0.11906462996609,\n0.15136080967773,\n0.16396720767670,\n0.15136080967773,\n0.11906462996609,\n0.07981140824009,\n0.04558899978527,\n0.02219054849244,\n#endif\n};\nconst uvec2 isize = uvec2(gl_WorkGroupSize) + uvec2(2 * taps);\nshared float grain[isize.y][isize.x];\n// PRNG\nfloat permute(float x)\n{\nx = (34.0 * x + 1.0) * x;\nreturn fract(x * 1.0/289.0) * 289.0;\n}\nfloat seed(uvec2 pos)\n{\nconst float phi = 1.61803398874989;\nvec3 m = vec3(fract(phi * vec2(pos)), random) + vec3(1.0);\nreturn permute(permute(m.x) + m.y) + m.z;\n}\nfloat rand(inout float state)\n{\nstate = permute(state);\nreturn fract(state * 1.0/41.0);\n}\n// Turns uniform white noise into gaussian white noise by passing it\n// through an approximation of the gaussian quantile function\nfloat rand_gaussian(inout float state) {\nconst float a0 = 0.151015505647689;\nconst float a1 = -0.5303572634357367;\nconst float a2 = 1.365020122861334;\nconst float b0 = 0.132089632343748;\nconst float b1 = -0.7607324991323768;\nfloat p = 0.95 * rand(state) + 0.025;\nfloat q = p - 0.5;\nfloat r = q * q;\nfloat g = q * (a2 + (a1 * r + a0) / (r*r + b1*r + b0));\ng *= 0.255121822830526; // normalize to [-1,1)\nreturn g;\n}\nvoid hook()\n{\n// generate grain in `grain`\nuint num_threads = gl_WorkGroupSize.x * gl_WorkGroupSize.y;\nfor (uint i = gl_LocalInvocationIndex; i &lt; isize.y * isize.x; i += num_threads) {\nuvec2 pos = uvec2(i % isize.y, i / isize.y);\nfloat state = seed(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + pos);\ngrain[pos.y][pos.x] = rand_gaussian(state);\n}\n// make writes visible\nbarrier();\n// convolve horizontally\nfor (uint y = gl_LocalInvocationID.y; y &lt; isize.y; y += gl_WorkGroupSize.y) {\nfloat hsum = 0;\nfor (uint x = 0; x &lt; row_size; x++) {\nfloat g = grain[y][gl_LocalInvocationID.x + x];\nhsum += weights[x] * g;\n}\n// update grain LUT\ngrain[y][gl_LocalInvocationID.x + taps] = hsum;\n}\nbarrier();\n// convolve vertically\nfloat vsum = 0.0;\nfor (uint y = 0; y &lt; row_size; y++) {\nfloat g = grain[gl_LocalInvocationID.y + y][gl_LocalInvocationID.x + taps];\nvsum += weights[y] * g;\n}\nvec4 color = HOOKED_tex(HOOKED_pos);\ncolor.rgb += vec3(intensity * vsum);\nimageStore(out_image, ivec2(gl_GlobalInvocationID), color);\n}\n</code></pre> <ol> <li> <p>Because these are macros, their presence can be tested for using   <code>#ifdef</code> inside the GLSL preprocessor.\u00a0\u21a9</p> </li> <li> <p>In mpv using <code>--vo=gpu-next</code>, these can be set using the   <code>--glsl-shader-opts</code> option.\u00a0\u21a9</p> </li> <li> <p>On supported platforms, these are implemented using specialization   constants, which can be updated at run-time without requiring a full shader   recompilation.\u00a0\u21a9</p> </li> </ol>"},{"location":"renderer/","title":"Rendering content: pl_frame, pl_renderer, and pl_queue","text":"<p>This example roughly builds off the previous entry, and as such will not cover the basics of how to create a window, initialize a <code>pl_gpu</code> and get pixels onto the screen.</p>"},{"location":"renderer/#renderer","title":"Renderer","text":"<p>The <code>pl_renderer</code> set of APIs represents the highest-level interface into libplacebo, and is what most users who simply want to display e.g. a video feed on-screen will want to be using.</p> <p>The basic initialization is straightforward, requiring no extra parameters:</p> <pre><code>pl_renderer renderer;\ninit()\n{\nrenderer = pl_renderer_create(pllog, gpu);\nif (!renderer)\ngoto error;\n// ...\n}\nuninit()\n{\npl_renderer_destroy(&amp;renderer);\n}\n</code></pre> <p>What makes the renderer powerful is the large number of <code>pl_render_params</code> it exposes. By default, libplacebo provides several presets to use:</p> <ul> <li>pl_render_fast_params: Disables everything except for defaults. This is   the fastest possible configuration.</li> <li>pl_render_default_params: Contains the recommended default parameters,   including some slightly higher quality scaling, as well as dithering.</li> <li>pl_render_high_quality_params: A preset of reasonable defaults for a   higher-end machine (i.e. anything with a discrete GPU). This enables most   of the basic functionality, including upscaling, downscaling, debanding   and better HDR tone mapping.</li> </ul> <p>Covering all of the possible options exposed by <code>pl_render_params</code> is out-of-scope of this example and would be better served by looking at the API documentation.</p>"},{"location":"renderer/#frames","title":"Frames","text":"<p><code>pl_frame</code> is the struct libplacebo uses to group textures and their metadata together into a coherent unit that can be rendered using the renderer. This is not currently a dynamically allocated or refcounted heap object, it is merely a struct that can live on the stack (or anywhere else). The actual data lives in corresponding <code>pl_tex</code> objects referenced in each of the frame's planes.</p> <pre><code>bool render_frame(const struct pl_frame *image,\nconst struct pl_swapchain_frame *swframe)\n{\nstruct pl_frame target;\npl_frame_from_swapchain(&amp;target, swframe);\nreturn pl_render_image(renderer, image, target,\n&amp;pl_render_default_params);\n}\n</code></pre> <p>Renderer state</p> <p>The <code>pl_renderer</code> is conceptually (almost) stateless. The only thing that is needed to get a different result is to change the render params, which can be varied freely on every call, if the user desires.</p> <p>The one case where this is not entirely true is when using frame mixing (see below), or when using HDR peak detection. In this case, the renderer can be explicitly reset using <code>pl_renderer_flush_cache</code>.</p> <p>To upload frames, the easiest methods are made available as dedicated helpers in <code>&lt;libplacebo/utils/upload.h&gt;</code>, and <code>&lt;libplacebo/utils/libav.h&gt;</code> (for AVFrames). In general, I recommend checking out the demo programs for a clearer illustration of how to use them in practice.</p>"},{"location":"renderer/#shader-cache","title":"Shader cache","text":"<p>The renderer internally generates, compiles and caches a potentially large number of shader programs, some of which can be complex. On some platforms (notably D3D11), these can be quite costly to recompile on every program launch.</p> <p>As such, the renderer offers a way to save/restore its internal shader cache from some external location (managed by the API user). The use of this API is highly recommended:</p> <pre><code>static uint8_t *load_saved_cache();\nstatic void store_saved_cache(uint8_t *cache, size_t bytes);\nvoid init()\n{\nrenderer = pl_renderer_create(pllog, gpu);\nif (!renderer)\ngoto error;\nuint8_t *cache = load_saved_cache();\nif (cache) {\npl_renderer_load(renderer, cache);\nfree(cache);\n}\n// ...\n}\nvoid uninit()\n{\nsize_t cache_bytes = pl_renderer_save(renderer, NULL);\nuint8_t *cache = malloc(cache_bytes);\nif (cache) {\npl_renderer_save(renderer, cache);\nstore_saved_cache(cache, cache_bytes);\nfree(cache);\n}\npl_renderer_destroy(&amp;renderer);\n}\n</code></pre> <p>Cache safety</p> <p>libplacebo performs only minimal validity checking on the shader cache, and in general, cannot possibly guard against malicious alteration of such files. Loading a cache from an untrusted source represents a remote code execution vector.</p>"},{"location":"renderer/#frame-mixing","title":"Frame mixing","text":"<p>One of the renderer's most powerful features is its ability to compensate for differences in framerates between the source and display by using frame mixing to blend adjacent frames together.</p> <p>Using this API requires presenting the renderer, at each vsync, with a <code>pl_frame_mix</code> struct, describing the current state of the vsync. In principle, such structs can be constructed by hand. To do this, all of the relevant frames (nearby the vsync timestamp) must be collected, and their relative distances to the vsync determined, by normalizing all PTS values such that the vsync represents time <code>0.0</code> (and a distance of <code>1.0</code> represents the nominal duration between adjacent frames). Note that timing vsyncs, and determining the correct vsync duration, are both left as problems for the user to solve.1. Here could be an example of a valid struct:</p> <pre><code>(struct pl_frame_mix) {\n.num_frames = 6\n.frames = (const struct pl_frame *[]) {\n/* frame 0 */\n/* frame 1 */\n/* ... */\n/* frame 5 */\n},\n.signatures = (uint64_t[]) {\n0x0, 0x1, 0x2, 0x3, 0x4, 0x5 // (1)\n},\n.timestamps = (float[]) {\n-2.4, -1.4, -0.4, 0.6, 1.6, 2.6, // (2)\n},\n.vsync_duration = 0.4, // 24 fps video on 60 fps display\n}\n</code></pre> <ol> <li> <p>These must be unique per frame, but always refer to the same frame. For     example, this could be based on the frame's PTS, the frame's numerical ID     (in order of decoding), or some sort of hash. The details don't matter,     only that this uniquely identifies specific frames.</p> </li> <li> <p>Typically, for CFR sources, frame timestamps will always be separated in     this list by a distance of 1.0. In this example, the vsync falls roughly     halfway (but not quite) in between two adjacent frames (with IDs 0x2 and     0x3).</p> </li> </ol> <p>Frame mixing radius</p> <p>In this example, the frame mixing radius (as determined by <code>pl_frame_mix_radius</code> is <code>3.0</code>, so we include all frames that fall within the timestamp interval of <code>[-3, 3)</code>. In general, you should consult this function to determine what frames need to be included in the <code>pl_frame_mix</code> - though including more frames than needed is not an error.</p>"},{"location":"renderer/#frame-queue","title":"Frame queue","text":"<p>Because this API is rather unwieldy and clumsy to use directly, libplacebo provides a helper abstraction known as <code>pl_queue</code> to assist in transforming some arbitrary source of frames (such as a video decoder) into nicely packed <code>pl_frame_mix</code> structs ready for consumption by the <code>pl_renderer</code>:</p> <pre><code>#include &lt;libplacebo/utils/frame_queue.h&gt;\npl_queue queue;\nvoid init()\n{\nqueue = pl_queue_create(gpu);\n}\nvoid uninit()\n{\npl_queue_destroy(&amp;queue);\n// ...\n}\n</code></pre> <p>This queue can be interacted with through a number of mechanisms: either pushing frames (blocking or non-blocking), or by having the queue poll frames (via blocking or non-blocking callback) as-needed. For a full overview of the various methods of pushing and polling frames, check the API documentation.</p> <p>In this example, I will assume that we have a separate decoder thread pushing frames into the <code>pl_queue</code> in a blocking manner:</p> <pre><code>static void decoder_thread(void)\n{\nvoid *frame;\nwhile ((frame = /* decode new frame */)) {\npl_queue_push_block(queue, UINT64_MAX, &amp;(struct pl_source_frame) {\n.pts        = /* frame pts */,\n.duration   = /* frame duration */,\n.map        = /* map callback */,\n.unmap      = /* unmap callback */,\n.frame_data = frame,\n});\n}\npl_queue_push(queue, NULL); // signal EOF\n}\n</code></pre> <p>Now, in our render loop, we want to call <code>pl_queue_update</code> with appropriate values to retrieve the correct frame mix for each vsync:</p> <pre><code>bool render_frame(const struct pl_swapchain_frame *swframe)\n{\nstruct pl_frame_mix mix;\nenum pl_queue_status res;\nres = pl_queue_update(queue, &amp;mix, pl_queue_params(\n.pts            = /* time of next vsync */,\n.radius         = pl_frame_mix_radius(&amp;render_params),\n.vsync_duration = /* if known */,\n.timeout        = UINT64_MAX, // (2)\n));\nswitch (res) {\ncase PL_QUEUE_OK:\nbreak;\ncase PL_QUEUE_EOF:\n/* no more frames */\nreturn false;\ncase PL_QUEUE_ERR:\ngoto error;\n// (1)\n}\nstruct pl_frame target;\npl_frame_from_swapchain(&amp;target, swframe);\nreturn pl_render_image_mix(renderer, &amp;mix, target,\n&amp;pl_render_default_params);\n}\n</code></pre> <ol> <li> <p>There is a fourth status, <code>PL_QUEUE_MORE</code>, which is returned only if the     resulting frame mix is incomplete (and the timeout was reached) -     basically this can only happen if the queue runs dry due to frames not     being supplied fast enough.</p> <p>In this example, since we are setting <code>timeout</code> to <code>UINT64_MAX</code>, we will never get this return value.</p> </li> <li> <p>Setting this makes <code>pl_queue_update</code> block indefinitely until sufficiently     many frames have been pushed into the <code>pl_queue</code> from our separate     decoding thread.</p> </li> </ol>"},{"location":"renderer/#deinterlacing","title":"Deinterlacing","text":"<p>The frame queue also vastly simplifies the process of performing motion-adaptive temporal deinterlacing, by automatically linking together adjacent fields/frames. To take advantage of this, all you need to do is set the appropriate field (<code>pl_source_frame.first_frame</code>), as well as enabling deinterlacing parameters.</p> <ol> <li> <p>However, this may change in the future, as the recent introduction of   the Vulkan display timing extension may result in display timing feedback   being added to the <code>pl_swapchain</code> API. That said, as of writing, this has   not yet happened.\u00a0\u21a9</p> </li> </ol>"}]}